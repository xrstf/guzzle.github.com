
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>HTTP client for PHP &mdash; Guzzle 3.0.0 documentation</title>
    
    <link rel="stylesheet" href="../_static/basic.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/bootstrap.css?v=5" type="text/css" />
    <link rel="stylesheet" href="../_static/bootstrap-sphinx.css?v=9" type="text/css" />
    <link rel="stylesheet" href="../_static/prettify/prettify.css?v=4" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '3.0.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/prettify/prettify.js"></script>
    <link rel="top" title="Guzzle 3.0.0 documentation" href="../index.html" />
    <link rel="up" title="Tour" href="index.html" />
    <link rel="next" title="Consuming web services using web service clients" href="using_services.html" />
    <link rel="prev" title="Installation" href="installation.html" />

<script type="text/javascript">
(function () {
  /**
   * Patch TOC list.
   *
   * Will mutate the underlying span to have a correct ul for nav.
   *
   * @param $span: Span containing nested UL's to mutate.
   * @param minLevel: Starting level for nested lists. (1: global, 2: local).
   */
  var patchToc = function ($span, minLevel) {
    var $tocList = $("<ul/>").attr('class', "dropdown-menu"),
      findA;

    // Find all a "internal" tags, traversing recursively.
    findA = function ($elem, level) {
      var level = level || 0,
        $items = $elem.find("> li > a.internal, > ul, > li > ul");

      // Iterate everything in order.
      $items.each(function (index, item) {
        var $item = $(item),
          tag = item.tagName.toLowerCase(),
          pad = 10 + ((level - minLevel) * 10);

        if (tag === 'a' && level >= minLevel) {
          // Add to existing padding.
          $item.css('padding-left', pad + "px");
          // Add list element.
          $tocList.append($("<li/>").append($item));
        } else if (tag === 'ul') {
          // Recurse.
          findA($item, level + 1);
        }
      });
    };

    // Start construction and return.
    findA($span);

    // Wipe out old list and patch in new one.
    return $span.empty("ul").append($tocList);
  };

  $(document).ready(function () {
    // Patch the global and local TOC's to be bootstrap-compliant.
    patchToc($("span.globaltoc"), 1);
    patchToc($("span.localtoc"), 2);
  });
}());
</script>

  </head>
  <body>
    <div class="navbar navbar-inverse navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container">
          <a class="brand" href="../index.html">Guzzle</a>
          <div class="nav-collapse collapse">
            <ul class="nav">
              <li class="">
                <a href="../index.html">Home</a>
              </li>
              <li class="">
                <a href="../docs.html">Docs</a>
              </li>
              <li class="">
                <a href="https://github.com/guzzle/guzzle">GitHub</a>
              </li>
              <li class="">
                <a href="https://groups.google.com/forum/?hl=en#!forum/guzzle">Forum</a>
              </li>
              <li>
                <a href="irc:irc.freenode.com/#guzzlephp">IRC</a>
              </li>
            </ul>
            
              
<form class="navbar-search pull-right" action="../search.html" method="get" placehold="Search">
  <input type="text" name="q" placeholder="Search" class="search-query" />
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
            
          </div>
        </div>
      </div>
    </div>

  
    <div class="container">
      
        <div class="guzzle-sidebar">
  <div class="well">
      <h4>Table of contents</h4>
      <ul>
<li><a class="reference internal" href="#">HTTP client for PHP</a><ul>
<li><a class="reference internal" href="#using-a-client-object">Using a Client object</a><ul>
<li><a class="reference internal" href="#base-urls">Base URLs</a></li>
<li><a class="reference internal" href="#configuration-options">Configuration options</a></li>
</ul>
</li>
<li><a class="reference internal" href="#sending-requests-and-using-responses">Sending requests and using responses</a><ul>
<li><a class="reference internal" href="#requests">Requests</a><ul>
<li><a class="reference internal" href="#query-strings">Query strings</a></li>
<li><a class="reference internal" href="#put">PUT</a></li>
<li><a class="reference internal" href="#post">POST</a></li>
</ul>
</li>
<li><a class="reference internal" href="#responses">Responses</a><ul>
<li><a class="reference internal" href="#json-responses">JSON Responses</a></li>
<li><a class="reference internal" href="#xml-responses">XML Responses</a></li>
</ul>
</li>
<li><a class="reference internal" href="#request-and-response-headers">Request and response headers</a></li>
<li><a class="reference internal" href="#redirects">Redirects</a><ul>
<li><a class="reference internal" href="#redirects-and-non-repeatable-streams">Redirects and non-repeatable streams</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#cookies">Cookies</a><ul>
<li><a class="reference internal" href="#dealing-with-errors">Dealing with errors</a><ul>
<li><a class="reference internal" href="#exceptions">Exceptions</a></li>
<li><a class="reference internal" href="#curl-errors">cURL errors</a></li>
</ul>
</li>
<li><a class="reference internal" href="#entity-bodies">Entity Bodies</a></li>
<li><a class="reference internal" href="#send-http-requests-in-parallel">Send HTTP requests in parallel</a></li>
<li><a class="reference internal" href="#managed-persistent-http-connections">Managed persistent HTTP connections</a></li>
<li><a class="reference internal" href="#low-level-curl-access">Low level cURL access</a></li>
</ul>
</li>
<li><a class="reference internal" href="#uri-templates">URI templates</a></li>
<li><a class="reference internal" href="#plugins-for-common-http-request-behavior">Plugins for common HTTP request behavior</a></li>
</ul>
</li>
</ul>

  </div>
  <div class="well">
    <h4>Need support?</h4>
    <p>Please post to our <a href="https://groups.google.com/forum/?hl=en#!forum/guzzle">google group</a> if you need support or have a technical question.</p>
    <h4>Found an error?</h4>
    <p>If you find an error in the documentation, please <a href="https://github.com/guzzle/guzzle-docs">file a ticket</a> or <a href="https://github.com/guzzle/guzzle-docs">submit a pull request</a>.</p>
    <h4>Wanna help?</h4>
    <p>Clone the <a href="https://github.com/guzzle/guzzle-docs">guzzle-docs</a> repo and submit pull requests.</p>
  </div>
</div>
      
      <div class="content">
        
  <div class="section" id="http-client-for-php">
<h1>HTTP client for PHP<a class="headerlink" href="#http-client-for-php" title="Permalink to this headline">¶</a></h1>
<p>Guzzle gives PHP developers complete control over HTTP requests while utilizing HTTP/1.1 best practices. Guzzle&#8217;s HTTP
functionality is a robust framework built on top of the <a class="reference external" href="http://www.php.net/curl">PHP libcurl bindings</a>.</p>
<div class="section" id="using-a-client-object">
<h2>Using a Client object<a class="headerlink" href="#using-a-client-object" title="Permalink to this headline">¶</a></h2>
<p>Requests can be created by using methods of the <tt class="docutils literal"><span class="pre">Guzzle\Http\Client</span></tt> object. When instantiating a client object, you
can pass an optional &#8220;base URL&#8221; and optional array of configuration options. A base URL is the full URL of the server
you are connecting to, and it can include query string parameters and a base path.</p>
<div class="highlight-php"><div class="highlight"><pre><span class="k">use</span> <span class="nx">Guzzle\Http\Client</span><span class="p">;</span>

<span class="nv">$client</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Client</span><span class="p">(</span><span class="s1">&#39;https://api.github.com&#39;</span><span class="p">);</span>
<span class="nv">$request</span> <span class="o">=</span> <span class="nv">$client</span><span class="o">-&gt;</span><span class="na">get</span><span class="p">(</span><span class="s1">&#39;/user&#39;</span><span class="p">)</span><span class="o">-&gt;</span><span class="na">setAuth</span><span class="p">(</span><span class="s1">&#39;user&#39;</span><span class="p">,</span> <span class="s1">&#39;pass&#39;</span><span class="p">);</span>
<span class="nv">$response</span> <span class="o">=</span> <span class="nv">$request</span><span class="o">-&gt;</span><span class="na">send</span><span class="p">();</span>

<span class="k">echo</span> <span class="nv">$response</span><span class="o">-&gt;</span><span class="na">getBody</span><span class="p">();</span>
<span class="c1">// &gt;&gt;&gt; {&quot;type&quot;:&quot;User&quot;, ...</span>
<span class="k">echo</span> <span class="nv">$response</span><span class="o">-&gt;</span><span class="na">getHeader</span><span class="p">(</span><span class="s1">&#39;Content-Length&#39;</span><span class="p">);</span>
<span class="c1">// &gt;&gt;&gt; 792</span>
<span class="nv">$data</span> <span class="o">=</span> <span class="nv">$response</span><span class="o">-&gt;</span><span class="na">json</span><span class="p">();</span>
<span class="k">echo</span> <span class="nv">$data</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">];</span>
<span class="c1">// &gt;&gt;&gt; User</span>
</pre></div>
</div>
<div class="section" id="base-urls">
<h3>Base URLs<a class="headerlink" href="#base-urls" title="Permalink to this headline">¶</a></h3>
<p>Notice that the URI provided to the client&#8217;s <tt class="docutils literal"><span class="pre">get()</span></tt> method is relative. Relative URIs will always merge into the
base URL of the client. There are a few rules that control how the URIs are merged.</p>
<p>In the above example, we passed <tt class="docutils literal"><span class="pre">/user</span></tt> to the <tt class="docutils literal"><span class="pre">get()</span></tt> method of the client. This is a relative URI, so it will
merge into the base URL of the client&#8211; resulting in the derived URL of <tt class="docutils literal"><span class="pre">https://api.github.com/users</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">/user</span></tt> is a relative URL but uses an absolute path because it contains the leading slash. Absolute paths will
overwrite any existing path of the base URL. If an absolute path is provided (e.g. <tt class="docutils literal"><span class="pre">/path/to/something</span></tt>), then the
path specified in the base URL of the client will be replaced with the absolute path, and the query string provided
will replace the query string of the base URL.</p>
<p>Omitting the leading slash and using relative paths will add to the path of the base URL of the client. So using a
client base URL of <tt class="docutils literal"><span class="pre">https://api.twitter.com/v1.1</span></tt> and creating a GET request with <tt class="docutils literal"><span class="pre">statuses/user_timeline.json</span></tt>
will result in a URL of <tt class="docutils literal"><span class="pre">https://api.twitter.com/v1.1/statuses/user_timeline.json</span></tt>. If a relative path and a query
string are provided, then the relative path will be appended to the base URL path, and the query string provided will
be merged into the query string of the base URL.</p>
<p>If an absolute URL is provided (e.g. <tt class="docutils literal"><span class="pre">http://httpbin.org/ip</span></tt>), then the request will completely use the absolute URL
as-is without merging in any of the URL parts specified in the base URL.</p>
</div>
<div class="section" id="configuration-options">
<h3>Configuration options<a class="headerlink" href="#configuration-options" title="Permalink to this headline">¶</a></h3>
<p>The second argument of the client&#8217;s constructor is an array of configuration data. This can include URI template data
or special options that alter the client&#8217;s behavior:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">curl.options</span></tt>: Associative array of cURL options to apply to every request created by the client.</li>
<li><tt class="docutils literal"><span class="pre">ssl.certificate_authority</span></tt>: Set to true to use the bundled SSL certificate bundle, <tt class="docutils literal"><span class="pre">system</span></tt> to use the bundle on
your system, a string pointing to a file to use a specific certificate authority, a string pointing to a directory
to use multiple certificates, or <tt class="docutils literal"><span class="pre">false</span></tt> to disable SSL validation.</li>
<li><tt class="docutils literal"><span class="pre">request.params</span></tt>: Associative array of parameters to apply to the parameter collection of every request created by
the client.</li>
<li><tt class="docutils literal"><span class="pre">command.params</span></tt>: When using a <tt class="docutils literal"><span class="pre">Guzzle\Service\Client</span></tt> object, this is an associative array of default options to
set on each command created by the client.</li>
</ul>
<div class="highlight-php"><div class="highlight"><pre><span class="k">use</span> <span class="nx">Guzzle\Http\Client</span><span class="p">;</span>

<span class="nv">$client</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Client</span><span class="p">(</span><span class="s1">&#39;https://api.twitter.com/{version}&#39;</span><span class="p">,</span> <span class="k">array</span><span class="p">(</span>
    <span class="s1">&#39;version&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;v1.1&#39;</span><span class="p">,</span>
    <span class="s1">&#39;curl.options&#39;</span> <span class="o">=&gt;</span> <span class="k">array</span><span class="p">(</span>
        <span class="nx">CURLOPT_PROXY</span> <span class="o">=&gt;</span> <span class="s1">&#39;tcp://localhost:80&#39;</span>
    <span class="p">),</span>
    <span class="s1">&#39;ssl.certificate_authority&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;system&#39;</span><span class="p">,</span>
    <span class="s1">&#39;request.params&#39;</span> <span class="o">=&gt;</span> <span class="k">array</span><span class="p">(</span>
        <span class="s1">&#39;foo&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;bar&#39;</span>
    <span class="p">)</span>
<span class="p">));</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="sending-requests-and-using-responses">
<h2>Sending requests and using responses<a class="headerlink" href="#sending-requests-and-using-responses" title="Permalink to this headline">¶</a></h2>
<div class="section" id="requests">
<h3>Requests<a class="headerlink" href="#requests" title="Permalink to this headline">¶</a></h3>
<p>Requests can be created from a client using method names that match the HTTP verb. Guzzle supports the following HTTP
methods: GET, HEAD, DELETE, PUT, POST, PATCH, and OPTIONS. You can use any other custom HTTP method by calling
<tt class="docutils literal"><span class="pre">$client-&gt;createRequest($methodName)</span></tt>.</p>
<div class="highlight-php"><div class="highlight"><pre><span class="k">use</span> <span class="nx">Guzzle\Http\Client</span><span class="p">;</span>

<span class="nv">$client</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Client</span><span class="p">(</span><span class="s1">&#39;http://baseurl.com/api/v1&#39;</span><span class="p">);</span>

<span class="c1">// Relative to base URL (http://baseurl.com/api/v1/path?query=123&amp;value=abc)</span>
<span class="nv">$request</span> <span class="o">=</span> <span class="nv">$client</span><span class="o">-&gt;</span><span class="na">get</span><span class="p">(</span><span class="s1">&#39;path?query=123&amp;value=abc&#39;</span><span class="p">);</span>

<span class="c1">// Overrides base URL&#39;s path (http://baseurl.com/path?query=123&amp;value=abc)</span>
<span class="nv">$request</span> <span class="o">=</span> <span class="nv">$client</span><span class="o">-&gt;</span><span class="na">head</span><span class="p">(</span><span class="s1">&#39;/path?query=123&amp;value=abc&#39;</span><span class="p">);</span>

<span class="c1">// Delete using an Absolute URL</span>
<span class="nv">$request</span> <span class="o">=</span> <span class="nv">$client</span><span class="o">-&gt;</span><span class="na">delete</span><span class="p">(</span><span class="s1">&#39;http://www.example.com/path?query=123&amp;value=abc&#39;</span><span class="p">);</span>

<span class="c1">// Create a PUT request using the contents of a PHP stream as the body</span>
<span class="nv">$request</span> <span class="o">=</span> <span class="nv">$client</span><span class="o">-&gt;</span><span class="na">put</span><span class="p">(</span><span class="s1">&#39;http://www.example.com/upload&#39;</span><span class="p">,</span> <span class="k">array</span><span class="p">(</span>
    <span class="s1">&#39;X-Header&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;My Header&#39;</span>
<span class="p">),</span> <span class="nb">fopen</span><span class="p">(</span><span class="s1">&#39;http://www.test.com/&#39;</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">));</span>

<span class="c1">// Create a POST request and add the POST files manually</span>
<span class="nv">$request</span> <span class="o">=</span> <span class="nv">$client</span><span class="o">-&gt;</span><span class="na">post</span><span class="p">(</span><span class="s1">&#39;http://localhost:8983/solr/update&#39;</span><span class="p">)</span>
    <span class="o">-&gt;</span><span class="na">addPostFiles</span><span class="p">(</span><span class="k">array</span><span class="p">(</span><span class="s1">&#39;file&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;/path/to/documents.xml&#39;</span><span class="p">));</span>

<span class="c1">// Check if a resource supports the DELETE method</span>
<span class="nv">$supportsDelete</span> <span class="o">=</span> <span class="nv">$client</span><span class="o">-&gt;</span><span class="na">options</span><span class="p">(</span><span class="s1">&#39;/path&#39;</span><span class="p">)</span><span class="o">-&gt;</span><span class="na">send</span><span class="p">()</span><span class="o">-&gt;</span><span class="na">isMethodAllowed</span><span class="p">(</span><span class="s1">&#39;DELETE&#39;</span><span class="p">);</span>
</pre></div>
</div>
<p>If you know exactly what HTTP message you want to send, you can create request objects from messages:</p>
<div class="highlight-php"><div class="highlight"><pre><span class="k">use</span> <span class="nx">Guzzle\Http\Message\RequestFactory</span><span class="p">;</span>

<span class="nv">$request</span> <span class="o">=</span> <span class="nx">RequestFactory</span><span class="o">::</span><span class="na">fromMessage</span><span class="p">(</span>
    <span class="s2">&quot;PUT / HTTP/1.1</span><span class="se">\r\n</span><span class="s2">&quot;</span> <span class="o">.</span>
    <span class="s2">&quot;Host: test.com:8081</span><span class="se">\r\n</span><span class="s2">&quot;</span> <span class="o">.</span>
    <span class="s2">&quot;Content-Type: text/plain</span><span class="se">\r\n</span><span class="s2">&quot;</span> <span class="o">.</span>
    <span class="s2">&quot;Transfer-Encoding: chunked</span><span class="se">\r\n\r\n</span><span class="s2">&quot;</span> <span class="o">.</span>
    <span class="s2">&quot;this is the body&quot;</span>
<span class="p">);</span>
</pre></div>
</div>
<p>Request objects are all about building an HTTP message. Each part of an HTTP request message can be set individually
using methods on the request object or set in bulk using the <tt class="docutils literal"><span class="pre">setUrl()</span></tt> method. Here&#8217;s the format of an HTTP request
with each part of the request referencing the method used to change it:</p>
<div class="highlight-php"><div class="highlight"><pre><span class="nx">PUT</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="o">/</span><span class="nx">path</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span><span class="o">?</span><span class="nx">query</span><span class="o">=</span><span class="mi">123</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span> <span class="nx">HTTP</span><span class="o">/</span><span class="mf">1.1</span><span class="p">(</span><span class="nx">d</span><span class="p">)</span>
<span class="nx">X</span><span class="o">-</span><span class="nx">Header</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span><span class="o">:</span> <span class="nx">header</span>
<span class="nx">Content</span><span class="o">-</span><span class="nx">Length</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span><span class="o">:</span> <span class="mi">4</span>

<span class="nx">data</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span>
</pre></div>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="24%" />
<col width="76%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><ol class="first last loweralpha simple">
<li><strong>Method</strong></li>
</ol>
</td>
<td>The request method can only be set when instantiating a request</td>
</tr>
<tr class="row-even"><td><ol class="first last loweralpha simple" start="2">
<li><strong>Path</strong></li>
</ol>
</td>
<td><tt class="docutils literal"><span class="pre">$request-&gt;setPath('/path');</span></tt></td>
</tr>
<tr class="row-odd"><td><ol class="first last loweralpha simple" start="3">
<li><strong>Query</strong></li>
</ol>
</td>
<td><tt class="docutils literal"><span class="pre">$request-&gt;getQuery()-&gt;set('query',</span> <span class="pre">'123');</span></tt></td>
</tr>
<tr class="row-even"><td><ol class="first last loweralpha simple" start="4">
<li><strong>Protocol version</strong></li>
</ol>
</td>
<td><tt class="docutils literal"><span class="pre">$request-&gt;setProtocolVersion('1.1');</span></tt></td>
</tr>
<tr class="row-odd"><td><ol class="first last loweralpha simple" start="5">
<li><strong>Header</strong></li>
</ol>
</td>
<td><tt class="docutils literal"><span class="pre">$request-&gt;setHeader('X-Header',</span> <span class="pre">'header');</span></tt></td>
</tr>
<tr class="row-even"><td><ol class="first last loweralpha simple" start="6">
<li><strong>Entity Body</strong></li>
</ol>
</td>
<td><tt class="docutils literal"><span class="pre">$request-&gt;setBody('data');</span> <span class="pre">//</span> <span class="pre">Only</span> <span class="pre">available</span> <span class="pre">with</span> <span class="pre">PUT,</span> <span class="pre">POST,</span> <span class="pre">PATCH,</span> <span class="pre">DELETE</span></tt></td>
</tr>
</tbody>
</table>
<div class="section" id="query-strings">
<h4>Query strings<a class="headerlink" href="#query-strings" title="Permalink to this headline">¶</a></h4>
<p>Query string parameters of a request are owned by a request&#8217;s <tt class="docutils literal"><span class="pre">Guzzle\Http\Query</span></tt> object that is accessible by
calling <tt class="docutils literal"><span class="pre">$request-&gt;getQuery()</span></tt>. The Query class extends from <tt class="docutils literal"><span class="pre">Guzzle\Common\Collection</span></tt> and allows you to set one
or more query string parameters as key value pairs. You can set a parameter on a Query object using the
<tt class="docutils literal"><span class="pre">set($key,</span> <span class="pre">$value)</span></tt> method. Any previously specified value for a key will be overwritten when using <tt class="docutils literal"><span class="pre">set()</span></tt>. Use
<tt class="docutils literal"><span class="pre">add($key,</span> <span class="pre">$value)</span></tt> to add a value to query string object, and in the event of a collision with an existing value at
a specific key, the value will be converted to an array that contains all of the previously set values.</p>
<div class="highlight-php"><div class="highlight"><pre><span class="nv">$request</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Guzzle\Http\Message\Request</span><span class="p">(</span><span class="s1">&#39;GET&#39;</span><span class="p">,</span> <span class="s1">&#39;http://www.example.com?foo=bar&amp;abc=123&#39;</span><span class="p">);</span>

<span class="nv">$query</span> <span class="o">=</span> <span class="nv">$request</span><span class="o">-&gt;</span><span class="na">getQuery</span><span class="p">();</span>
<span class="k">echo</span> <span class="s2">&quot;</span><span class="si">{</span><span class="nv">$query</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">;</span>
<span class="c1">//&gt; foo=bar&amp;abc=123</span>

<span class="nv">$query</span><span class="o">-&gt;</span><span class="na">remove</span><span class="p">(</span><span class="s1">&#39;abc&#39;</span><span class="p">);</span>
<span class="k">echo</span> <span class="s2">&quot;</span><span class="si">{</span><span class="nv">$query</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">;</span>
<span class="c1">//&gt; foo=bar</span>

<span class="nv">$query</span><span class="o">-&gt;</span><span class="na">set</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="s1">&#39;baz&#39;</span><span class="p">);</span>
<span class="k">echo</span> <span class="s2">&quot;</span><span class="si">{</span><span class="nv">$query</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">;</span>
<span class="c1">//&gt; foo=baz</span>

<span class="nv">$query</span><span class="o">-&gt;</span><span class="na">add</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="s1">&#39;bar&#39;</span><span class="p">);</span>
<span class="k">echo</span> <span class="s2">&quot;</span><span class="si">{</span><span class="nv">$query</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">;</span>
<span class="c1">//&gt; foo%5B0%5D=baz&amp;foo%5B1%5D=bar</span>
</pre></div>
</div>
<p>Whoah! What happened there? When <tt class="docutils literal"><span class="pre">foo=bar</span></tt> was added to the existing <tt class="docutils literal"><span class="pre">foo=baz</span></tt> query string parameter, the
aggregator associated with the Query object was used to help convert multi-value query string parameters into a string.
Let&#8217;s disable URL-encoding to better see what&#8217;s happening.</p>
<div class="highlight-php"><div class="highlight"><pre><span class="nv">$query</span><span class="o">-&gt;</span><span class="na">useUrlEncoding</span><span class="p">(</span><span class="k">false</span><span class="p">);</span>
<span class="k">echo</span> <span class="s2">&quot;</span><span class="si">{</span><span class="nv">$query</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">;</span>
<span class="c1">//&gt; foo[0]=baz&amp;foo[1]=bar</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">URL encoding can be disabled by passing false, enabled by passing true, set to use RFC 1738 by passing
<tt class="docutils literal"><span class="pre">Query::FORM_URLENCODED</span></tt> (uses <tt class="docutils literal"><span class="pre">urlencode</span></tt>), or set to RFC 3986 by passing <tt class="docutils literal"><span class="pre">Query::RFC_3986</span></tt> (this is the
default and uses <tt class="docutils literal"><span class="pre">rawurlencode</span></tt>).</p>
</div>
<p>As you can see, the multiple values were converted into query string parameters following the default PHP convention of
adding numerically indexed bracket suffixes to each key (<tt class="docutils literal"><span class="pre">foo[0]=baz&amp;foo[1]=bar</span></tt>). The strategy used to convert
mutli-value parameters into a string can be customized using the <tt class="docutils literal"><span class="pre">setAggregator()</span></tt> method of the Query class. Guzzle
ships with the following aggregators by default:</p>
<ol class="arabic simple">
<li><tt class="docutils literal"><span class="pre">Guzzle\Http\QueryAggregator\PhpAggregator</span></tt>: Aggregates using PHP style brackets (e.g. <tt class="docutils literal"><span class="pre">foo[0]=baz&amp;foo[1]=bar</span></tt>)</li>
<li><tt class="docutils literal"><span class="pre">Guzzle\Http\QueryAggregator\DuplicateAggregator</span></tt>: Performs no aggregation and allows for key value pairs to be
repeated in a URL (e.g. <tt class="docutils literal"><span class="pre">foo=baz&amp;foo=bar</span></tt>)</li>
<li><tt class="docutils literal"><span class="pre">Guzzle\Http\QueryAggregator\CommaAggregator</span></tt>: Aggregates using commas (e.g. <tt class="docutils literal"><span class="pre">foo=baz,bar</span></tt>)</li>
</ol>
</div>
<div class="section" id="put">
<h4>PUT<a class="headerlink" href="#put" title="Permalink to this headline">¶</a></h4>
<p>You can send PUT requests with raw entity bodies:</p>
<div class="highlight-php"><div class="highlight"><pre><span class="nv">$response</span> <span class="o">=</span> <span class="nv">$client</span><span class="o">-&gt;</span><span class="na">put</span><span class="p">(</span><span class="s1">&#39;http://httpbin.org/put&#39;</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="s1">&#39;this is the body&#39;</span><span class="p">)</span><span class="o">-&gt;</span><span class="na">send</span><span class="p">();</span>
</pre></div>
</div>
</div>
<div class="section" id="post">
<h4>POST<a class="headerlink" href="#post" title="Permalink to this headline">¶</a></h4>
<p>Guzzle helps to make it extremely easy to send POST requests. POST requests will be sent with an
<tt class="docutils literal"><span class="pre">application/x-www-form-urlencoded</span></tt> Content-Type header if no files are being sent in the POST. If files are
specified in the POST, then the Content-Type header will become <tt class="docutils literal"><span class="pre">multipart/form-data</span></tt>. Here&#8217;s how to create a
multipart/form-data POST request containing files and fields:</p>
<div class="highlight-php"><div class="highlight"><pre><span class="nv">$request</span> <span class="o">=</span> <span class="nv">$client</span><span class="o">-&gt;</span><span class="na">post</span><span class="p">(</span><span class="s1">&#39;http://httpbin.org/post&#39;</span><span class="p">)</span>
    <span class="o">-&gt;</span><span class="na">addPostFields</span><span class="p">(</span><span class="k">array</span><span class="p">(</span><span class="s1">&#39;custom_key&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;value&#39;</span><span class="p">))</span>
    <span class="o">-&gt;</span><span class="na">addPostFiles</span><span class="p">(</span><span class="k">array</span><span class="p">(</span><span class="s1">&#39;file&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;/path/to/file.xml&#39;</span><span class="p">));</span>
</pre></div>
</div>
<p>This can be achieved more succinctly&#8211; <tt class="docutils literal"><span class="pre">post()</span></tt> accepts three arguments: the URL, optional headers, and the post
fields. To send files in the POST request, prepend the <tt class="docutils literal"><span class="pre">&#64;</span></tt> symbol to the array value (just like you would if you
were using the PHP <tt class="docutils literal"><span class="pre">curl_setopt</span></tt> function):</p>
<div class="highlight-php"><div class="highlight"><pre><span class="nv">$request</span> <span class="o">=</span> <span class="nv">$client</span><span class="o">-&gt;</span><span class="na">post</span><span class="p">(</span><span class="s1">&#39;http://www.example.com/upload&#39;</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">array</span><span class="p">(</span>
    <span class="s1">&#39;custom_field&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;my custom value&#39;</span><span class="p">,</span>
    <span class="s1">&#39;file_field&#39;</span>   <span class="o">=&gt;</span> <span class="s1">&#39;@/path/to/file.xml&#39;</span>
<span class="p">));</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Remember to <strong>always</strong> sanitize user input when sending POST requests:</p>
<div class="last highlight-php"><div class="highlight"><pre><span class="c1">// Prevent users from accessing sensitive files by sanitizing input</span>
<span class="nv">$_POST</span> <span class="o">=</span> <span class="k">array</span><span class="p">(</span><span class="s1">&#39;firstname&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;@/etc/passwd&#39;</span><span class="p">);</span>
<span class="nv">$request</span> <span class="o">=</span> <span class="nv">$client</span><span class="o">-&gt;</span><span class="na">post</span><span class="p">(</span><span class="s1">&#39;http://www.example.com&#39;</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">array</span> <span class="p">(</span>
    <span class="s1">&#39;firstname&#39;</span> <span class="o">=&gt;</span> <span class="nb">str_replace</span><span class="p">(</span><span class="s1">&#39;@&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="nv">$_POST</span><span class="p">[</span><span class="s1">&#39;firstname&#39;</span><span class="p">])</span>
<span class="p">));</span>
</pre></div>
</div>
</div>
<p>You can send POST requests with raw entity bodies:</p>
<div class="highlight-php"><div class="highlight"><pre><span class="nv">$response</span> <span class="o">=</span> <span class="nv">$client</span><span class="o">-&gt;</span><span class="na">post</span><span class="p">(</span><span class="s1">&#39;http://httpbin.org/post&#39;</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="s1">&#39;this is the body&#39;</span><span class="p">)</span><span class="o">-&gt;</span><span class="na">send</span><span class="p">();</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="responses">
<h3>Responses<a class="headerlink" href="#responses" title="Permalink to this headline">¶</a></h3>
<p>Sending a request will return a <tt class="docutils literal"><span class="pre">Guzzle\Http\Message\Response</span></tt> object. You can view the HTTP response message by
casting the Response object to a string. Casting the response to a string will return the entity body of the response
as a string too, so this might be an expensive operation if the entity body is stored in a file or network stream. If
you only want to see the response headers, you can call <tt class="docutils literal"><span class="pre">getRawHeaders()</span></tt>.</p>
<p>The Response object contains helper methods for retrieving common response headers. These helper methods normalize the
variations of HTTP response headers:</p>
<div class="highlight-php"><div class="highlight"><pre><span class="nv">$response</span><span class="o">-&gt;</span><span class="na">getContentMd5</span><span class="p">();</span>
<span class="nv">$response</span><span class="o">-&gt;</span><span class="na">getEtag</span><span class="p">();</span>
<span class="nv">$response</span><span class="o">-&gt;</span><span class="na">getCacheControl</span><span class="p">();</span>
<span class="nv">$response</span><span class="o">-&gt;</span><span class="na">getHeader</span><span class="p">(</span><span class="s1">&#39;Content-Length&#39;</span><span class="p">);</span>
<span class="c1">// ... There are methods for every known response header</span>
</pre></div>
</div>
<p>The entity body object of a response can be retrieved by calling <tt class="docutils literal"><span class="pre">$response-&gt;getBody()</span></tt>. The response EntityBody can
be cast to a string, or you can pass <tt class="docutils literal"><span class="pre">true</span></tt> to this method to retrieve the body as a string.</p>
<div class="section" id="json-responses">
<h4>JSON Responses<a class="headerlink" href="#json-responses" title="Permalink to this headline">¶</a></h4>
<p>You can easily parse and use a JSON response as an array using the <tt class="docutils literal"><span class="pre">json()</span></tt> method of a response. This method will
always return an array if the response is valid JSON or if the response body is empty. You will get an exception if you
call this method and the response is not valid JSON:</p>
<div class="highlight-php"><div class="highlight"><pre><span class="nv">$data</span> <span class="o">=</span> <span class="nv">$response</span><span class="o">-&gt;</span><span class="na">json</span><span class="p">();</span>
<span class="k">echo</span> <span class="nb">gettype</span><span class="p">(</span><span class="nv">$data</span><span class="p">);</span>
<span class="c1">// &gt;&gt;&gt; array</span>
</pre></div>
</div>
</div>
<div class="section" id="xml-responses">
<h4>XML Responses<a class="headerlink" href="#xml-responses" title="Permalink to this headline">¶</a></h4>
<p>You can easily parse and use a XML response as SimpleXMLElement object using the <tt class="docutils literal"><span class="pre">xml()</span></tt> method of a response. This
method will always return a SimpleXMLElement object if the response is valid XML or if the response body is empty. You
will get an exception if you call this method and the response is not valid XML:</p>
<div class="highlight-php"><div class="highlight"><pre><span class="nv">$xml</span> <span class="o">=</span> <span class="nv">$response</span><span class="o">-&gt;</span><span class="na">xml</span><span class="p">();</span>
<span class="k">echo</span> <span class="nv">$xml</span><span class="o">-&gt;</span><span class="na">foo</span><span class="p">;</span>
<span class="c1">// &gt;&gt;&gt; Bar!</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="request-and-response-headers">
<h3>Request and response headers<a class="headerlink" href="#request-and-response-headers" title="Permalink to this headline">¶</a></h3>
<p>HTTP message headers are case insensitive, multiple occurrences of any header can be present in an HTTP message
(whether it&#8217;s valid or not), and some servers require specific casing of particular headers. Because of this, request
and response headers are stored in <tt class="docutils literal"><span class="pre">Guzzle\Http\Message\Header</span></tt> objects. The Header object can be cast as a string,
counted, or iterated to retrieve each value from the header. Casting a Header object to a string will return all of
the header values concatenated together using a glue string (typically &#8216;, &#8216;). Let&#8217;s take the following example to see
what is returned:</p>
<div class="highlight-php"><div class="highlight"><pre><span class="nv">$request</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Request</span><span class="p">(</span><span class="s1">&#39;GET&#39;</span><span class="p">,</span> <span class="s1">&#39;http://httpbin.com/cookies&#39;</span><span class="p">);</span>
<span class="c1">// addHeader will set and append to any existing header values</span>
<span class="nv">$request</span><span class="o">-&gt;</span><span class="na">addHeader</span><span class="p">(</span><span class="s1">&#39;Foo&#39;</span><span class="p">,</span> <span class="s1">&#39;bar&#39;</span><span class="p">);</span>
<span class="nv">$request</span><span class="o">-&gt;</span><span class="na">addHeader</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="s1">&#39;baz&#39;</span><span class="p">);</span>
<span class="c1">// setHeader overwrites any existing values</span>
<span class="nv">$request</span><span class="o">-&gt;</span><span class="na">setHeader</span><span class="p">(</span><span class="s1">&#39;Test&#39;</span><span class="p">,</span> <span class="s1">&#39;123&#39;</span><span class="p">);</span>

<span class="c1">// Requests can be cast as a string</span>
<span class="k">echo</span> <span class="nv">$request</span><span class="o">-&gt;</span><span class="na">getHeader</span><span class="p">(</span><span class="s1">&#39;Foo&#39;</span><span class="p">);</span>
<span class="c1">// &gt;&gt;&gt; bar, baz</span>
<span class="k">echo</span> <span class="nv">$request</span><span class="o">-&gt;</span><span class="na">getHeader</span><span class="p">(</span><span class="s1">&#39;Test&#39;</span><span class="p">);</span>
<span class="c1">// &gt;&gt;&gt; &quot;123&quot;</span>

<span class="c1">// You can count the number of headers of a particular case insensitive name</span>
<span class="k">echo</span> <span class="nb">count</span><span class="p">(</span><span class="nv">$request</span><span class="o">-&gt;</span><span class="na">getHeader</span><span class="p">(</span><span class="s1">&#39;foO&#39;</span><span class="p">));</span>
<span class="c1">// &gt;&gt;&gt; 2</span>

<span class="c1">// You can iterate over Header objects</span>
<span class="k">foreach</span> <span class="p">(</span><span class="nv">$request</span><span class="o">-&gt;</span><span class="na">getHeader</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="nv">$header</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">echo</span> <span class="nv">$header</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Missing headers return NULL</span>
<span class="nb">var_export</span><span class="p">(</span><span class="nv">$request</span><span class="o">-&gt;</span><span class="na">getHeader</span><span class="p">(</span><span class="s1">&#39;Missing&#39;</span><span class="p">));</span>
<span class="c1">// &gt;&gt;&gt; null</span>

<span class="c1">// You can see all of the different variations of a header by calling raw() on the Header</span>
<span class="nb">var_export</span><span class="p">(</span><span class="nv">$request</span><span class="o">-&gt;</span><span class="na">getHeader</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">)</span><span class="o">-&gt;</span><span class="na">raw</span><span class="p">());</span>
</pre></div>
</div>
</div>
<div class="section" id="redirects">
<h3>Redirects<a class="headerlink" href="#redirects" title="Permalink to this headline">¶</a></h3>
<p>By default, Guzzle will automatically follow redirects using the non-RFC compliant implementation used by most web
browsers. This means that redirects for POST requests are followed by a GET request. You can force RFC compliance by
enabling the strict mode on a request&#8217;s parameter object:</p>
<div class="highlight-php"><div class="highlight"><pre><span class="c1">// Set per request</span>
<span class="nv">$request</span> <span class="o">=</span> <span class="nv">$client</span><span class="o">-&gt;</span><span class="na">post</span><span class="p">();</span>
<span class="nv">$request</span><span class="o">-&gt;</span><span class="na">getParams</span><span class="p">()</span><span class="o">-&gt;</span><span class="na">set</span><span class="p">(</span><span class="s1">&#39;redirect.strict&#39;</span><span class="p">,</span> <span class="k">true</span><span class="p">);</span>
<span class="c1">// Set globally on a client so that all requests use strict redirects</span>
<span class="nv">$client</span><span class="o">-&gt;</span><span class="na">getConfig</span><span class="p">()</span><span class="o">-&gt;</span><span class="na">set</span><span class="p">(</span><span class="s1">&#39;request.params&#39;</span><span class="p">,</span> <span class="k">array</span><span class="p">(</span><span class="s1">&#39;redirect.strict&#39;</span> <span class="o">=&gt;</span> <span class="k">true</span><span class="p">));</span>
</pre></div>
</div>
<p>By default, Guzzle will redirect up to 5 times before throwing a <tt class="docutils literal"><span class="pre">Guzzle\Http\Exception\TooManyRedirectsException</span></tt>.
You can raise or lower this value using the <tt class="docutils literal"><span class="pre">redirect.max</span></tt> parameter of a request object:</p>
<div class="highlight-php"><div class="highlight"><pre><span class="nv">$request</span><span class="o">-&gt;</span><span class="na">getParams</span><span class="p">()</span><span class="o">-&gt;</span><span class="na">set</span><span class="p">(</span><span class="s1">&#39;redirect.max&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
</pre></div>
</div>
<p>You can get the full chain of request/response objects that were sent to complete an HTTP transaction using the
<tt class="docutils literal"><span class="pre">getPreviousResponse()</span></tt> method of a response object.:</p>
<div class="highlight-php"><div class="highlight"><pre><span class="nv">$response</span> <span class="o">=</span> <span class="nv">$request</span><span class="o">-&gt;</span><span class="na">send</span><span class="p">();</span>

<span class="k">do</span> <span class="p">{</span>
    <span class="k">echo</span> <span class="s2">&quot;</span><span class="si">{</span><span class="nv">$response</span><span class="si">}</span><span class="se">\n\n</span><span class="s2">&quot;</span><span class="p">;</span>
    <span class="nv">$response</span> <span class="o">=</span> <span class="nv">$response</span><span class="o">-&gt;</span><span class="na">getPreviousResponse</span><span class="p">();</span>
<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="nv">$response</span><span class="p">);</span>
</pre></div>
</div>
<p>You can disable redirects on a client by passing a configuration option in the client&#8217;s constructor:</p>
<div class="highlight-php"><div class="highlight"><pre><span class="nv">$client</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Client</span><span class="p">(</span><span class="k">null</span><span class="p">,</span> <span class="k">array</span><span class="p">(</span><span class="s1">&#39;redirect.disable&#39;</span> <span class="o">=&gt;</span> <span class="k">true</span><span class="p">));</span>
</pre></div>
</div>
<p>You can also disable redirects per request:</p>
<div class="highlight-php"><div class="highlight"><pre><span class="nv">$request</span><span class="o">-&gt;</span><span class="na">getParams</span><span class="p">()</span><span class="o">-&gt;</span><span class="na">set</span><span class="p">(</span><span class="s1">&#39;redirect.disable&#39;</span><span class="p">,</span> <span class="k">true</span><span class="p">);</span>
</pre></div>
</div>
<div class="section" id="redirects-and-non-repeatable-streams">
<h4>Redirects and non-repeatable streams<a class="headerlink" href="#redirects-and-non-repeatable-streams" title="Permalink to this headline">¶</a></h4>
<p>If you are redirected when sending data from a non-repeatable stream and some of the data has been read off of the
stream, then you will get a <tt class="docutils literal"><span class="pre">Guzzle\Http\Exception\CouldNotRewindStreamException</span></tt>. You can get around this error by
adding a custom rewind method to the entity body object being sent in the request:</p>
<div class="highlight-php"><div class="highlight"><pre><span class="nv">$request</span> <span class="o">=</span> <span class="nv">$client</span><span class="o">-&gt;</span><span class="na">post</span><span class="p">(</span><span class="s1">&#39;http://httpbin.com/redirect/2&#39;</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="nb">fopen</span><span class="p">(</span><span class="s1">&#39;http://httpbin.com/get&#39;</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">));</span>
<span class="c1">// Add a custom function that can be used to rewind the stream (reopen in this example)</span>
<span class="nv">$request</span><span class="o">-&gt;</span><span class="na">getBody</span><span class="p">()</span><span class="o">-&gt;</span><span class="na">setRewindFunction</span><span class="p">(</span><span class="k">function</span> <span class="p">(</span><span class="nv">$body</span><span class="p">)</span> <span class="p">{</span>
    <span class="nv">$body</span><span class="o">-&gt;</span><span class="na">setStream</span><span class="p">(</span><span class="nb">fopen</span><span class="p">(</span><span class="s1">&#39;http://httpbin.com/get&#39;</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">));</span>
    <span class="k">return</span> <span class="k">true</span><span class="p">;</span>
<span class="p">);</span>
<span class="nv">$response</span> <span class="o">=</span> <span class="nv">$client</span><span class="o">-&gt;</span><span class="na">send</span><span class="p">();</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="cookies">
<h2>Cookies<a class="headerlink" href="#cookies" title="Permalink to this headline">¶</a></h2>
<p>Cookies can be modified and retrieved from a request using the following methods:</p>
<div class="highlight-php"><div class="highlight"><pre><span class="nv">$request</span><span class="o">-&gt;</span><span class="na">addCookie</span><span class="p">(</span><span class="nv">$name</span><span class="p">,</span> <span class="nv">$value</span><span class="p">);</span>
<span class="nv">$request</span><span class="o">-&gt;</span><span class="na">removeCookie</span><span class="p">(</span><span class="nv">$name</span><span class="p">);</span>
<span class="nv">$value</span> <span class="o">=</span> <span class="nv">$request</span><span class="o">-&gt;</span><span class="na">getCookie</span><span class="p">(</span><span class="nv">$name</span><span class="p">);</span>
<span class="nv">$valueArray</span> <span class="o">=</span> <span class="nv">$request</span><span class="o">-&gt;</span><span class="na">getCookies</span><span class="p">();</span>
</pre></div>
</div>
<p>Use the <a class="reference internal" href="../guide/plugins.html"><em>cookie plugin</em></a> if you need to reuse cookies between requests.</p>
<div class="section" id="dealing-with-errors">
<h3>Dealing with errors<a class="headerlink" href="#dealing-with-errors" title="Permalink to this headline">¶</a></h3>
<div class="section" id="exceptions">
<h4>Exceptions<a class="headerlink" href="#exceptions" title="Permalink to this headline">¶</a></h4>
<p>Requests that receive a 4xx or 5xx response will throw a <tt class="docutils literal"><span class="pre">Guzzle\Http\Exception\BadResponseException</span></tt>. More
specifically, 4xx errors throw a <tt class="docutils literal"><span class="pre">Guzzle\Http\Exception\ClientErrorResponseException</span></tt>, and 5xx errors throw a
<tt class="docutils literal"><span class="pre">Guzzle\Http\Exception\ServerErrorResponseException</span></tt>. You can catch the specific exceptions or just catch the
BadResponseException to deal with either type of error. Here&#8217;s an example of catching a generic BadResponseException:</p>
<div class="highlight-php"><div class="highlight"><pre><span class="k">try</span> <span class="p">{</span>
    <span class="nv">$response</span> <span class="o">=</span> <span class="nv">$client</span><span class="o">-&gt;</span><span class="na">get</span><span class="p">(</span><span class="s1">&#39;/not_found.xml&#39;</span><span class="p">)</span><span class="o">-&gt;</span><span class="na">send</span><span class="p">();</span>
<span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">Guzzle\Http\Exception\BadResponseException</span> <span class="nv">$e</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">echo</span> <span class="s1">&#39;Uh oh! &#39;</span> <span class="o">.</span> <span class="nv">$e</span><span class="o">-&gt;</span><span class="na">getMessage</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Throwing an exception when a 4xx or 5xx response is encountered is the default behavior of Guzzle requests. This
behavior can be overridden by adding an event listener with a higher priority than -255 that stops event propagation.
You can subscribe to <tt class="docutils literal"><span class="pre">request.error</span></tt> to receive notifications any time an unsuccessful response is received.</p>
<p>You can change the response that will be associated with the request by calling <tt class="docutils literal"><span class="pre">setResponse()</span></tt> on the
<tt class="docutils literal"><span class="pre">$event['request']</span></tt> object passed into your listener, or by changing the <tt class="docutils literal"><span class="pre">$event['response']</span></tt> value of the
<tt class="docutils literal"><span class="pre">Guzzle\Common\Event</span></tt> object that is passed to your listener. Transparently changing the response associated with a
request by modifying the event allows you to retry failed requests without complicating the code that uses the client.
This might be useful for sending requests to a web service that has expiring auth tokens. When a response shows that
your token has expired, you can get a new token, retry the request with the new token, and return the successful
response to the user.</p>
<p>Here&#8217;s an example of retrying a request using updated authorization credentials when a 401 response is received,
overriding the response of the original request with the new response, and still allowing the default exception
behavior to be called when other non-200 response status codes are encountered:</p>
<div class="highlight-php"><div class="highlight"><pre><span class="c1">// Add custom error handling to any request created by this client</span>
<span class="nv">$client</span><span class="o">-&gt;</span><span class="na">getEventDispatcher</span><span class="p">()</span><span class="o">-&gt;</span><span class="na">addListener</span><span class="p">(</span><span class="s1">&#39;request.error&#39;</span><span class="p">,</span> <span class="k">function</span><span class="p">(</span><span class="nx">Event</span> <span class="nv">$event</span><span class="p">)</span> <span class="p">{</span>

    <span class="k">if</span> <span class="p">(</span><span class="nv">$event</span><span class="p">[</span><span class="s1">&#39;response&#39;</span><span class="p">]</span><span class="o">-&gt;</span><span class="na">getStatusCode</span><span class="p">()</span> <span class="o">==</span> <span class="mi">401</span><span class="p">)</span> <span class="p">{</span>

        <span class="nv">$newRequest</span> <span class="o">=</span> <span class="nv">$event</span><span class="p">[</span><span class="s1">&#39;request&#39;</span><span class="p">]</span><span class="o">-&gt;</span><span class="na">clone</span><span class="p">();</span>
        <span class="nv">$newRequest</span><span class="o">-&gt;</span><span class="na">setHeader</span><span class="p">(</span><span class="s1">&#39;X-Auth-Header&#39;</span><span class="p">,</span> <span class="nx">MyApplication</span><span class="o">::</span><span class="na">getNewAuthToken</span><span class="p">());</span>
        <span class="nv">$newResponse</span> <span class="o">=</span> <span class="nv">$newRequest</span><span class="o">-&gt;</span><span class="na">send</span><span class="p">();</span>

        <span class="c1">// Set the response object of the request without firing more events</span>
        <span class="nv">$event</span><span class="p">[</span><span class="s1">&#39;response&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nv">$newResponse</span><span class="p">;</span>

        <span class="c1">// You can also change the response and fire the normal chain of</span>
        <span class="c1">// events by calling $event[&#39;request&#39;]-&gt;setResponse($newResponse);</span>

        <span class="c1">// Stop other events from firing when you override 401 responses</span>
        <span class="nv">$event</span><span class="o">-&gt;</span><span class="na">stopPropagation</span><span class="p">();</span>
    <span class="p">}</span>

<span class="p">});</span>
</pre></div>
</div>
</div>
<div class="section" id="curl-errors">
<h4>cURL errors<a class="headerlink" href="#curl-errors" title="Permalink to this headline">¶</a></h4>
<p>Connection problems and cURL specific errors can also occur when transferring requests using Guzzle. When Guzzle
encounters cURL specific errors while transferring a single request, a <tt class="docutils literal"><span class="pre">Guzzle\Http\Exception\CurlException</span></tt> is
thrown with an informative error message and access to the cURL error message.</p>
<p>A <tt class="docutils literal"><span class="pre">Guzzle\Common\Exception\ExceptionCollection</span></tt> exception is thrown when a cURL specific error occurs while
transferring multiple requests in parallel. You can then iterate over all of the exceptions encountered during the
transfer.</p>
</div>
</div>
<div class="section" id="entity-bodies">
<h3>Entity Bodies<a class="headerlink" href="#entity-bodies" title="Permalink to this headline">¶</a></h3>
<p><a class="reference external" href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec7.html">Entity body</a> is the term used for the body of an HTTP
message. The entity body of requests and responses is inherently a
<a class="reference external" href="http://php.net/manual/en/book.stream.php">PHP stream</a> in Guzzle. The body of the request can be either a string or
a PHP stream which are converted into a <tt class="docutils literal"><span class="pre">Guzzle\Http\EntityBody</span></tt> object using its factory method. When using a
string, the entity body is stored in a <a class="reference external" href="http://www.php.net/manual/en/wrappers.php.php">temp PHP stream</a>. The use of
temp PHP streams helps to protect your application from running out of memory when sending or receiving large entity
bodies in your messages. When more than 2MB of data is stored in a temp stream, it automatically stores the data on
disk rather than in memory.</p>
<p>EntityBody objects provide a great deal of functionality: compression, decompression, calculate the Content-MD5,
calculate the Content-Length (when the resource is repeatable), guessing the Content-Type, and more. Guzzle doesn&#8217;t
need to load an entire entity body into a string when sending or retrieving data; entity bodies are streamed when
being uploaded and downloaded.</p>
<p>Here&#8217;s an example of gzip compressing a text file then sending the file to a URL:</p>
<div class="highlight-php"><div class="highlight"><pre><span class="k">use</span> <span class="nx">Guzzle\Http\EntityBody</span><span class="p">;</span>

<span class="nv">$body</span> <span class="o">=</span> <span class="nx">EntityBody</span><span class="o">::</span><span class="na">factory</span><span class="p">(</span><span class="nb">fopen</span><span class="p">(</span><span class="s1">&#39;/path/to/file.txt&#39;</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">));</span>
<span class="nv">$body</span><span class="o">-&gt;</span><span class="na">compress</span><span class="p">();</span>
<span class="nv">$response</span> <span class="o">=</span> <span class="nv">$client</span><span class="o">-&gt;</span><span class="na">put</span><span class="p">(</span><span class="s1">&#39;http://localhost:8080/uploads&#39;</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="nv">$body</span><span class="p">)</span><span class="o">-&gt;</span><span class="na">send</span><span class="p">();</span>
</pre></div>
</div>
<p>The body of the request can be specified in the <tt class="docutils literal"><span class="pre">Client::put()</span></tt> or <tt class="docutils literal"><span class="pre">Client::post()</span></tt>  method, or, you can specify
the body of the request by calling the <tt class="docutils literal"><span class="pre">setBody()</span></tt> method of any
<tt class="docutils literal"><span class="pre">Guzzle\Http\Message\EntityEnclosingRequestInterface</span></tt> object.</p>
<p>The entity body received from a response is stored in a temp stream by default. If you need the entity body of a
response to use a destination other than a temporary stream (e.g. FTP, HTTP, a specific file, an open stream), you can
set the entity body object that will be used to hold the response body by calling <tt class="docutils literal"><span class="pre">setResponseBody()</span></tt> on any request
object.</p>
</div>
<div class="section" id="send-http-requests-in-parallel">
<h3>Send HTTP requests in parallel<a class="headerlink" href="#send-http-requests-in-parallel" title="Permalink to this headline">¶</a></h3>
<p>Sending many HTTP requests serially (one at a time) can cause an unnecessary delay in a script&#8217;s execution. Each
request must complete before a subsequent request can be sent. By sending requests in parallel, a pool of HTTP
requests can complete at the speed of the slowest request in the pool, significantly reducing the amount of time
needed to execute multiple HTTP requests. Guzzle provides a wrapper for the curl_multi functions in PHP.</p>
<p>You can pass a single request or an array of requests to a client&#8217;s <tt class="docutils literal"><span class="pre">send()</span></tt> method. Here&#8217;s an example of sending
three requests in parallel using a client object:</p>
<div class="highlight-php"><div class="highlight"><pre><span class="k">use</span> <span class="nx">Guzzle\Common\Exception\ExceptionCollection</span><span class="p">;</span>

<span class="k">try</span> <span class="p">{</span>
    <span class="nv">$responses</span> <span class="o">=</span> <span class="nv">$client</span><span class="o">-&gt;</span><span class="na">send</span><span class="p">(</span><span class="k">array</span><span class="p">(</span>
        <span class="nv">$client</span><span class="o">-&gt;</span><span class="na">get</span><span class="p">(</span><span class="s1">&#39;http://www.google.com/&#39;</span><span class="p">),</span>
        <span class="nv">$client</span><span class="o">-&gt;</span><span class="na">head</span><span class="p">(</span><span class="s1">&#39;http://www.google.com/&#39;</span><span class="p">),</span>
        <span class="nv">$client</span><span class="o">-&gt;</span><span class="na">get</span><span class="p">(</span><span class="s1">&#39;https://www.github.com/&#39;</span><span class="p">)</span>
    <span class="p">));</span>
<span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">ExceptionCollection</span> <span class="nv">$e</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">echo</span> <span class="s2">&quot;The following exceptions were encountered:</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">;</span>
    <span class="k">foreach</span> <span class="p">(</span><span class="nv">$e</span> <span class="k">as</span> <span class="nv">$exception</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">echo</span> <span class="nv">$exception</span><span class="o">-&gt;</span><span class="na">getMessage</span><span class="p">()</span> <span class="o">.</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>A single request failure will not cause the entire pool of requests to fail. Any exceptions thrown while transferring
a pool of requests will be aggregated into a <tt class="docutils literal"><span class="pre">Guzzle\Common\Exception\ExceptionCollection</span></tt> exception.</p>
</div>
<div class="section" id="managed-persistent-http-connections">
<h3>Managed persistent HTTP connections<a class="headerlink" href="#managed-persistent-http-connections" title="Permalink to this headline">¶</a></h3>
<p>Persistent HTTP connections are an extremely important aspect of the HTTP/1.1 protocol that is often overlooked by
PHP HTTP clients. Persistent connections allows data to be transferred between a client and server without the need
to reconnect each time a subsequent request is sent, providing a significant performance boost to applications that
need to send many HTTP requests to the same host. Guzzle implicitly manages persistent connections for all requests.</p>
<p>All HTTP requests sent using the same client object will use the same cURL multi handle. cURL will maintain a cache of
persistent connections on a multi handle. More information about cURL&#8217;s internal design and persistent connection
handling can be found at <a class="reference external" href="http://curl.haxx.se/dev/internals.html">http://curl.haxx.se/dev/internals.html</a>.</p>
</div>
<div class="section" id="low-level-curl-access">
<h3>Low level cURL access<a class="headerlink" href="#low-level-curl-access" title="Permalink to this headline">¶</a></h3>
<p>Most of the functionality implemented in the libcurl bindings has been simplified and abstracted by Guzzle. Developers
who need access to <a class="reference external" href="http://www.php.net/curl_setopt">cURL specific functionality</a> that is not abstracted by Guzzle
(e.g. proxies and some SSL options) can still add cURL handle specific behavior to Guzzle HTTP requests by modifying
the cURL options collection of a request:</p>
<div class="highlight-php"><div class="highlight"><pre><span class="nv">$request</span><span class="o">-&gt;</span><span class="na">getCurlOptions</span><span class="p">()</span><span class="o">-&gt;</span><span class="na">set</span><span class="p">(</span><span class="nx">CURLOPT_SSL_VERIFYHOST</span><span class="p">,</span> <span class="k">true</span><span class="p">);</span>
</pre></div>
</div>
<p>You can add cURL options to every request sent from your client by adding configuration options to the <cite>curl.options</cite>
array. Clients will automatically map cURL constants for keys and values to their correct PHP value.</p>
<div class="highlight-php"><div class="highlight"><pre><span class="nv">$client</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Guzzle\Http\Client</span><span class="p">(</span><span class="s1">&#39;https://example.com/&#39;</span><span class="p">,</span> <span class="k">array</span><span class="p">(</span>
    <span class="s1">&#39;curl.options&#39;</span> <span class="o">=&gt;</span> <span class="k">array</span><span class="p">(</span>
        <span class="nx">CURLOPT_SSL_VERIFYHOST</span>   <span class="o">=&gt;</span> <span class="k">false</span><span class="p">,</span>
        <span class="s1">&#39;CURLOPT_SSL_VERIFYPEER&#39;</span> <span class="o">=&gt;</span> <span class="k">false</span><span class="p">,</span>
        <span class="nx">CURLOPT_PROXY</span>            <span class="o">=&gt;</span> <span class="s1">&#39;proxy.mydomain.com:8080&#39;</span><span class="p">,</span>
        <span class="s1">&#39;CURLOPT_PROXYTYPE&#39;</span>      <span class="o">=&gt;</span> <span class="s1">&#39;CURLPROXY_HTTP&#39;</span>
    <span class="p">)</span>
<span class="p">));</span>
</pre></div>
</div>
<p>If you are using <a class="reference internal" href="../guide/service/service_descriptions.html"><em>Service Descriptions</em></a> then you can override the cURL
options within the definition of an operation, for example:</p>
<div class="highlight-json"><div class="highlight"><pre><span class="p">{</span>
    <span class="nt">&quot;operations&quot;</span><span class="p">:</span> <span class="p">{</span>
        <span class="nt">&quot;get_users&quot;</span><span class="p">:</span> <span class="p">{</span>
            <span class="nt">&quot;httpMethod&quot;</span><span class="p">:</span> <span class="s2">&quot;GET&quot;</span><span class="p">,</span>
            <span class="nt">&quot;uri&quot;</span><span class="p">:</span> <span class="s2">&quot;/users&quot;</span><span class="p">,</span>
            <span class="nt">&quot;curl.options&quot;</span><span class="p">:</span> <span class="p">{</span>
                <span class="nt">&quot;CURLOPT_CONNECTTIMEOUT&quot;</span><span class="p">:</span> <span class="s2">&quot;100&quot;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>You can blacklist cURL options and headers from ever being sent by cURL by adding a <tt class="docutils literal"><span class="pre">blacklist</span></tt> configuration option
to the <tt class="docutils literal"><span class="pre">curl.options</span></tt> array of your client. The following example demonstrates how to blacklist the
<tt class="docutils literal"><span class="pre">CURLOPT_ENCODING</span></tt> option from ever being set on a request and prevents cURL from ever sending an <tt class="docutils literal"><span class="pre">Accept</span></tt> header
on any request.</p>
<div class="highlight-php"><div class="highlight"><pre><span class="nv">$client</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Guzzle\Http\Client</span><span class="p">(</span><span class="s1">&#39;https://example.com/&#39;</span><span class="p">,</span> <span class="k">array</span><span class="p">(</span>
    <span class="s1">&#39;curl.options&#39;</span> <span class="o">=&gt;</span> <span class="k">array</span><span class="p">(</span>
        <span class="s1">&#39;blacklist&#39;</span> <span class="o">=&gt;</span> <span class="k">array</span><span class="p">(</span><span class="nx">CURLOPT_ENCODING</span><span class="p">,</span> <span class="s1">&#39;header.Accept&#39;</span><span class="p">)</span>
    <span class="p">)</span>
<span class="p">));</span>
</pre></div>
</div>
<p>Other special options that can be set in the <tt class="docutils literal"><span class="pre">curl.options</span></tt> array include:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">debug</span></tt>: Adds verbose cURL output to a temp stream owned by the cURL handle object</li>
<li><tt class="docutils literal"><span class="pre">progress</span></tt>: Instructs cURL to emit events when IO events occur. This allows you to be notified when bytes are
transferred over the wire by subscribing to a request&#8217;s <tt class="docutils literal"><span class="pre">curl.callback.read</span></tt>, <tt class="docutils literal"><span class="pre">curl.callback.write</span></tt>, and
<tt class="docutils literal"><span class="pre">curl.callback.progress</span></tt> events.</li>
</ul>
</div>
</div>
<div class="section" id="uri-templates">
<h2>URI templates<a class="headerlink" href="#uri-templates" title="Permalink to this headline">¶</a></h2>
<p>Guzzle supports the entire <a class="reference external" href="http://tools.ietf.org/html/rfc6570">URI templates RFC</a>. URI templates add a special
syntax to URIs that replace template place holders with user defined variables.</p>
<p>Every request created by a Guzzle HTTP client passes through a URI template so that URI template expressions are
automatically expanded:</p>
<div class="highlight-php"><div class="highlight"><pre><span class="nv">$client</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Guzzle\Http\Client</span><span class="p">(</span><span class="s1">&#39;https://example.com/&#39;</span><span class="p">,</span> <span class="k">array</span><span class="p">(</span><span class="s1">&#39;a&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;hi&#39;</span><span class="p">));</span>
<span class="nv">$request</span> <span class="o">=</span> <span class="nv">$client</span><span class="o">-&gt;</span><span class="na">get</span><span class="p">(</span><span class="s1">&#39;/{a}&#39;</span><span class="p">);</span>
</pre></div>
</div>
<p>Because of URI template expansion, the URL of the above request will become <tt class="docutils literal"><span class="pre">https://example.com/hi</span></tt>. Notice that
the template was expanded using configuration variables of the client. You can pass in custom URI template variables
by passing the URI of your request as an array where the first index of the array is the URI template and the second
index of the array are template variables that are merged into the client&#8217;s configuration variables:</p>
<div class="highlight-php"><div class="highlight"><pre><span class="nv">$request</span> <span class="o">=</span> <span class="nv">$client</span><span class="o">-&gt;</span><span class="na">get</span><span class="p">(</span><span class="k">array</span><span class="p">(</span><span class="s1">&#39;/test{?a,b}&#39;</span><span class="p">,</span> <span class="k">array</span><span class="p">(</span><span class="s1">&#39;b&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;there&#39;</span><span class="p">));</span>
</pre></div>
</div>
<p>The URL for this request will become <tt class="docutils literal"><span class="pre">https://test.com?a=hi&amp;b=there</span></tt>. URI templates aren&#8217;t limited to just simple
variable replacements;  URI templates can provide an enormous amount of flexibility when creating request URIs:</p>
<div class="highlight-php"><div class="highlight"><pre><span class="nv">$request</span> <span class="o">=</span> <span class="nv">$client</span><span class="o">-&gt;</span><span class="na">get</span><span class="p">(</span><span class="k">array</span><span class="p">(</span><span class="s1">&#39;http://example.com{+path}{/segments}{?query,data*}&#39;</span><span class="p">,</span> <span class="k">array</span><span class="p">(</span>
    <span class="s1">&#39;path&#39;</span>     <span class="o">=&gt;</span> <span class="s1">&#39;/foo/bar&#39;</span><span class="p">,</span>
    <span class="s1">&#39;segments&#39;</span> <span class="o">=&gt;</span> <span class="k">array</span><span class="p">(</span><span class="s1">&#39;one&#39;</span><span class="p">,</span> <span class="s1">&#39;two&#39;</span><span class="p">),</span>
    <span class="s1">&#39;query&#39;</span>    <span class="o">=&gt;</span> <span class="s1">&#39;test&#39;</span><span class="p">,</span>
    <span class="s1">&#39;data&#39;</span>     <span class="o">=&gt;</span> <span class="k">array</span><span class="p">(</span>
        <span class="s1">&#39;more&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;value&#39;</span>
    <span class="p">)</span>
<span class="p">)));</span>
</pre></div>
</div>
<p>The resulting URL would become <tt class="docutils literal"><span class="pre">http://example.com/foo/bar/one/two?query=test&amp;more=value</span></tt>.</p>
<p>By default, URI template expressions are enclosed in an opening and closing brace (e.g. <tt class="docutils literal"><span class="pre">{var}</span></tt>). If you are working
with a web service that actually uses braces (e.g. Solr), then you can specify a custom regular expression to use to
match URI template expressions:</p>
<div class="highlight-php"><div class="highlight"><pre><span class="nv">$client</span><span class="o">-&gt;</span><span class="na">getUriTemplate</span><span class="p">()</span><span class="o">-&gt;</span><span class="na">setRegex</span><span class="p">(</span><span class="s1">&#39;/\&lt;\$(.+)\&gt;/&#39;</span><span class="p">);</span>
<span class="nv">$client</span><span class="o">-&gt;</span><span class="na">get</span><span class="p">(</span><span class="s1">&#39;/&lt;$a&gt;&#39;</span><span class="p">);</span>
</pre></div>
</div>
<p>You can learn about all of the different features of URI templates by reading the
<a class="reference external" href="http://tools.ietf.org/html/draft-gregorio-uritemplate-08">URI template RFC</a>.</p>
</div>
<div class="section" id="plugins-for-common-http-request-behavior">
<h2>Plugins for common HTTP request behavior<a class="headerlink" href="#plugins-for-common-http-request-behavior" title="Permalink to this headline">¶</a></h2>
<p>Guzzle provides easy to use request plugins that add behavior to requests based on signal slot event notifications.</p>
<p>View the plugin documentation here: <a class="reference internal" href="../guide/plugins.html"><em>Guzzle Plugins</em></a></p>
</div>
</div>


        
          
<div class="breadcrumb" style="margin: 24px 0; color:#999; text-align: center;">
  <a class="btn info" href="installation.html" title="previous chapter">&laquo; Installation</a>
  <a class="btn info" href="using_services.html" title="next chapter">Consuming web services using web service clients &raquo;</a>
</div>
          <div id="comments">
  <div id="disqus_thread"></div>
  <script type="text/javascript">
    var disqus_shortname = 'guzzle';
    var disqus_identifier = 'tour/http';
    (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>
        
      </div>
    </div>
  
<footer class="footer">
  <div class="container">
    <p class="pull-right"><a href="#">Back to top</a></p>
    <p>
    </p>
  </div>
  <script type="text/javascript">
    
    
  </script>
</footer>
  </body>
</html>