=======
Plugins
=======

Guzzle ships with a number of plugins that deal with both the ``Guzzle\Http`` and ``Guzzle\Service`` namespace.

.. note::

    Any event subscriber attached to the ``EventDispatcher`` of a ``Client`` object will automatically be attached to all request objects created by the client.  This allows you to attach, for example, a  HistoryPlugin to a client object, and from that point on, every request sent through that client will utilize the HistoryPlugin.

HTTP Plugins
------------

Guzzle provides easy to use request plugins that add behavior to requests based on signal slot event notifications.

Over the wire logging
~~~~~~~~~~~~~~~~~~~~~

Use the ``Guzzle\Http\Plugin\LogPlugin`` to view all data sent over the wire, including entity bodies and redirects::

    use Guzzle\Http\Client;
    use Guzzle\Common\Log\ZendLogAdapter;
    use Guzzle\Http\Plugin\LogPlugin;

    $client = new Client('http://www.test.com/');

    $adapter = new ZendLogAdapter(new \Zend_Log(new \Zend_Log_Writer_Stream('php://output')));
    $logPlugin = new LogPlugin($adapter, LogPlugin::LOG_VERBOSE);

    // Attach the plugin to the request, which will in turn be attached to all
    // requests generated by the client
    $client->addSubscriber($logPlugin);

    $response = $client->get('http://google.com')->send();

The code sample above wraps a ``Zend_Log`` object using a ``Guzzle\Common\Log\ZendLogAdapter``.  After attaching the request to the plugin, all data sent over the wire will be logged to stdout.  The above code sample would output something like:

.. code-block:: none

    2011-03-10T20:07:56-06:00 DEBUG (7): www.google.com - "GET / HTTP/1.1" - 200 0 - 0.195698 0 45887
    * About to connect() to google.com port 80 (#0)
    *   Trying 74.125.227.50... * connected
    * Connected to google.com (74.125.227.50) port 80 (#0)
    > GET / HTTP/1.1
    Accept: */*
    Accept-Encoding: deflate, gzip
    User-Agent: Guzzle/0.9 (Language=PHP/5.3.5; curl=7.21.2; Host=x86_64-apple-darwin10.4.0)
    Host: google.com

    < HTTP/1.1 301 Moved Permanently
    < Location: http://www.google.com/
    < Content-Type: text/html; charset=UTF-8
    < Date: Fri, 11 Mar 2011 02:06:32 GMT
    < Expires: Sun, 10 Apr 2011 02:06:32 GMT
    < Cache-Control: public, max-age=2592000
    < Server: gws
    < Content-Length: 219
    < X-XSS-Protection: 1; mode=block
    <
    * Ignoring the response-body
    * Connection #0 to host google.com left intact
    * Issue another request to this URL: 'http://www.google.com/'
    * About to connect() to www.google.com port 80 (#1)
    *   Trying 74.125.45.147... * connected
    * Connected to www.google.com (74.125.45.147) port 80 (#1)
    > GET / HTTP/1.1
    Host: www.google.com
    Accept: */*
    Accept-Encoding: deflate, gzip
    User-Agent: Guzzle/0.9 (Language=PHP/5.3.5; curl=7.21.2; Host=x86_64-apple-darwin10.4.0)

    < HTTP/1.1 200 OK
    < Date: Fri, 11 Mar 2011 02:06:32 GMT
    < Expires: -1
    < Cache-Control: private, max-age=0
    < Content-Type: text/html; charset=ISO-8859-1
    < Set-Cookie: PREF=ID=8a61470bce22ed5b:FF=0:TM=1299809192:LM=1299809192:S=axQwBxLyhXV7mbE3; expires=Sun, 10-Mar-2013 02:06:32 GMT; path=/; domain=.google.com
    < Set-Cookie: NID=44=qxXLtXgSKI2S9_mG7KbN7yR2atSje1B9Eft_CHTyjTuIivwE9kB1sATn_YPmBNhZHiNyxcP4_tIYnawjSNWeAepixK3CoKHw-RINrgGNSG3RfpAG7M-IKxHmLhJM6NeA; expires=Sat, 10-Sep-2011 02:06:32 GMT; path=/; domain=.google.com; HttpOnly
    < Server: gws
    < X-XSS-Protection: 1; mode=block
    < Transfer-Encoding: chunked
    <
    * Connection #1 to host www.google.com left intact
    <!doctype html><html><head>
    [...snipped]

Truncated exponential backoff
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The ``Guzzle\Http\Plugin\ExponentialBackoffPlugin`` automatically retries failed HTTP requests using truncated exponential backoff::

    use Guzzle\Http\Client;
    use Guzzle\Http\Plugin\ExponentialBackoffPlugin;

    $client = new Client('http://www.test.com/');

    $backoffPlugin = new ExponentialBackoffPlugin();

    // Add the exponential plugin to the client object
    $client->addSubscriber($backoffPlugin);

    $request = $client->get('http://google.com/');
    $request->send();

.. note::

    By default, the ExponentialBackoffPlugin will retry all 500 and 503 responses up to 3 times.  The number of retries and the HTTP status codes that are retried can be configured in the constructor of the plugin.

PHP-based caching forward proxy
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Guzzle can leverage HTTP's caching specifications using the ``Guzzle\Http\Plugin\CachePlugin``.  The CachePlugin provides a private transparent proxy cache that caches HTTP responses.  The caching logic, based on `RFC 2616 <http://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html>`_, uses HTTP headers to control caching behavior, cache lifetime, and supports ETag and Last-Modified based revalidation::

    use Guzzle\Http\Client;
    use Doctrine\Common\Cache\ArrayCache;
    use Guzzle\Common\Cache\DoctrineCacheAdapter;
    use Guzzle\Http\Plugin\CachePlugin;

    $client = new Client('http://www.test.com/');

    $adapter = new DoctrineCacheAdapter(new ArrayCache());
    $cachePlugin = new CachePlugin($adapter, true);

    // Add the cache plugin to the client object
    $client->addSubscriber($cachePlugin);

    $request = $client->get('http://www.wikipedia.org/');
    $request->send();

    // The next request will revalidate against the origin server to see if it
    // has been modified.  If a 304 response is recieved the response will be
    // served from cache
    $request->send();

Guzzle doesn't try to reinvent the wheel when it comes to caching or logging.  Plenty of other frameworks have excellent solutions in place that you are probably already using in your applications.  Guzzle uses adapters for caching and logging.  Guzzle currently supports log adapters for the Zend Framework 1.0/2.0 and Monolog, and cache adapters for `Doctrine 2.0 <http://www.doctrine-project.org/>`_ and the Zend Framework 1.0/2.0.

See :doc:`Caching </guide/http/caching>` for more information on the caching plugin.

Cookie session plugin
~~~~~~~~~~~~~~~~~~~~~

Some web services require a Cookie in order to maintain a session.  The ``Guzzle\Http\Plugin\CookiePlugin`` will add cookies to requests and parse cookies from responses using a CookieJar object::

    use Guzzle\Http\Client;
    use Guzzle\Http\Plugin\CookiePlugin;
    use Guzzle\Http\CookieJar\ArrayCookieJar;

    $client = new Client('http://www.test.com/');

    $cookiePlugin = new CookiePlugin(new ArrayCookieJar());

    // Add the cookie plugin to the client object
    $client->addSubscriber($cookiePlugin);

    $request = $client->get('http://www.yahoo.com/');

    // Send the request with no cookies and parse the returned cookies
    $request->send();

    // Send the request again, noticing that cookies are being sent
    $request->send();

    echo $request;

MD5 hash validator plugin
~~~~~~~~~~~~~~~~~~~~~~~~~

Entity bodies can sometimes be modified over the wire due to a faulty TCP transport or misbehaving proxy.  If an HTTP response contains a Content-MD5 header, then a MD5 hash of the entity body of a response can be compared against the Content-MD5 header of the response to determine if the response was delivered intact.  The ``Guzzle\Http\Plugin\Md5ValidatorPlugin`` will throw an ``UnexpectedValueException`` if the calculated MD5 hash does not match the Content-MD5 hash::

    use Guzzle\Http\Client;
    use Guzzle\Http\Plugin\Md5ValidatorPlugin;

    $client = new Client('http://www.test.com/');

    $md5Plugin = new Md5ValidatorPlugin();

    // Add the md5 plugin to the client object
    $client->addSubscriber($md5Plugin);

    $request = $client->get('http://www.yahoo.com/');
    $request->send();

Calculating the MD5 hash of a large entity body or an entity body that was transferred using a Content-Encoding is an expensive operation.  When working in high performance applications, you might consider skipping the MD5 hash validation for entity bodies bigger than a certain size or Content-Encoded entity bodies (see ``Guzzle\Http\Plugin\Md5ValidatorPlugin`` for more information).

History plugin
~~~~~~~~~~~~~~

The history plugin tracks all of the requests and responses sent through a request or client.  This plugin can be useful for crawling or unit testing.  By default, the history plugin stores up to 10 requests and responses.

.. code-block:: php

    use Guzzle\Http\Client;
    use Guzzle\Http\Plugin\HistoryPlugin;

    $client = new Client('http://www.test.com/');

    $history = new HistoryPlugin();
    $history->setLimit(5);

    // Add the history plugin to the client object
    $client->addSubscriber($history);

    $client->get('http://www.yahoo.com/')->send();

    echo $history->getLastRequest();
    echo $history->getLastResponse();
    echo count($history);

Mock Plugin
~~~~~~~~~~~

The mock plugin is useful for testing Guzzle clients.  The mock plugin allows you to queue an array of responses that will satisfy requests sent from a client by consuming the request queue in FIFO order.

.. code-block:: php

    use Guzzle\Http\Client;
    use Guzzle\Http\Plugin\MockPlugin;
    use Guzzle\Http\Message\Response;

    $client = new Client('http://www.test.com/');

    $mock = new MockPlugin();
    $mock->addResponse(new Response(200))
         ->addResponse(new Response(404));

    // Add the mock plugin to the client object
    $client->addSubscriber($mock);

    // The following request will receive a 200 response from the plugin
    $client->get('http://www.example.com/')->send();

    // The following request will receive a 404 response from the plugin
    $client->get('http://www.test.com/')->send();

.. _curl-auth:

Curl Auth Plugin
~~~~~~~~~~~~~~~~

If your web service client requires basic authorization, then you can use the CurlAuthPlugin to easily add an Authorization header to each request sent by the client.

.. code-block:: php

    use Guzzle\Http\Client;
    use Guzzle\Http\Plugin\CurlAuthPlugin;

    $client = new Client('http://www.test.com/');

    $authPlugin = new CurlAuthPlugin('username', 'password');

    // Add the auth plugin to the client object
    $client->addSubscriber($authPlugin);

    $response = $client->get('projects/1/people')->send();
    $xml = new SimpleXMLElement($response->getBody(true));
    foreach ($xml->person as $person) {
        echo $person->email . "\n";
    }

Batch Queue Plugin
~~~~~~~~~~~~~~~~~~

Send a large number of requests using the batch queue plugin.  Any request created by a client will automatically be tracked and queued by the BatchQueuePlugin. In the constructor of the plugin, you can specify the maximum amount of requests to keep in queue before implicitly flushing, or set 0 to never automatically flush.

.. code-block:: php

    use Guzzle\Http\Client;
    use Guzzle\Http\Plugin\BatchQueuePlugin;

    $client = new Client('http://www.test.com/');

    // Here we are saying that if 10 or more requests are in the batch queue,
    // then it must automatically flush the queue and send the requests.
    $batchPlugin = new BatchQueuePlugin(10);

    // Add the batch plugin to the client object
    $client->addSubscriber($batchPlugin);

    // Queue up some requests on the BatchQueuePlugin
    $request1 = $client->get('/');
    $request2 = $client->get('/');
    $request3 = $client->get('/');

    // If the batch plugin is handy, you can call the flush method directly
    $batchPlugin->flush();

    // If you no longer have the batch plugin handy, you can emit the 'flush' event
    // from the client
    $client->dispatch('flush');

OAuth 1.0 Plugin
~~~~~~~~~~~~~~~~

Guzzle ships with an OAuth 1.0 plugin that can sign requests using a consumer key, consumer secret, OAuth token, and OAuth secret.  Here's an example showing how to send an authenticated request to the Twitter REST API:

.. code-block:: php

    use Guzzle\Http\Client;
    use Guzzle\Http\Plugin\OauthPlugin;

    $client = new Client('http://api.twitter.com/1');
    $oauth = new OauthPlugin(array(
        'consumer_key'    => 'my_key',
        'consumer_secret' => 'my_secret',
        'token'           => 'my_token',
        'token_secret'    => 'my_token_secret'
    ));
    $client->addSubscriber($oauth);

    $response = $client->get('statuses/public_timeline.json')->send();

If you need to use a custom signing method, you can pass a ``signature_method`` configuration option in the constructor of the OAuth plugin.  The ``signature_method`` option must be a callable variable that accepts a string to sign and signing key and returns a signed string.

Async Plugin
~~~~~~~~~~~~

The AsyncPlugin allows you to send requests that do not wait on a response.  This is handled through cURL by utilizing the progress event.  When a request has sent all of its data to the remote server, Guzzle adds a 1ms timeout on the request and instructs cURL to not download the body of the response.  The async plugin then catches the exception and adds a mock response to the request, along with an X-Guzzle-Async header to let you know that the response was not fully downloaded.

.. code-block:: php

    use Guzzle\Http\Client;
    use Guzzle\Http\Plugin\AsyncPlugin;

    $client = new Client('http://www.example.com');
    $client->addSubscriber(new AsyncPlugin());
    $response = $client->get()->send();

Service Plugins
---------------

Plugin Collection Plugin
~~~~~~~~~~~~~~~~~~~~~~~~

This plugin can be used to attached plugins to every client created by a ``Guzzle\Service\Builder\ServiceBuilder``. The following example demonstrates adding a HistoryPlugin to each client created by a service builder.

.. code-block:: php

    use Guzzle\Service\Builder\ServiceBuilder;
    use Guzzle\Service\Plugin\PluginCollectionPlugin;

    $builder = ServiceBuilder::factory('config.json');
    $builder->addSubsriber(new PluginCollectionPlugin(array(new HistoryPlugin())));

Third-party plugins
~~~~~~~~~~~~~~~~~~~

* `WSSE Authentication plugin <https://github.com/davedevelopment/guzzle-wsse-auth-plugin>`_
